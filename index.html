<!DOCTYPE html>
<html lang="en-gb">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Oregon Scientific Weatherstation Decoder V1+V2</title>
    <style type="text/css">/*
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.6.0
*/
html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}del,ins{text-decoration:none;}body{font:13px/1.231 arial,helvetica,clean,sans-serif;*font-size:small;*font:x-small;}select,input,button,textarea{font:99% arial,helvetica,clean,sans-serif;}table{font-size:inherit;font:100%;}pre,code,kbd,samp,tt{font-family:monospace;*font-size:108%;line-height:100%;}body{text-align:center;}#ft{clear:both;}#doc,#doc2,#doc3,#doc4,.yui-t1,.yui-t2,.yui-t3,.yui-t4,.yui-t5,.yui-t6,.yui-t7{margin:auto;text-align:left;width:57.69em;*width:56.25em;min-width:750px;}#doc2{width:73.076em;*width:71.25em;}#doc3{margin:auto 10px;width:auto;}#doc4{width:74.923em;*width:73.05em;}.yui-b{position:relative;}.yui-b{_position:static;}#yui-main .yui-b{position:static;}#yui-main,.yui-g .yui-u .yui-g{width:100%;}{width:100%;}.yui-t1 #yui-main,.yui-t2 #yui-main,.yui-t3 #yui-main{float:right;margin-left:-25em;}.yui-t4 #yui-main,.yui-t5 #yui-main,.yui-t6 #yui-main{float:left;margin-right:-25em;}.yui-t1 .yui-b{float:left;width:12.30769em;*width:12.00em;}.yui-t1 #yui-main .yui-b{margin-left:13.30769em;*margin-left:13.05em;}.yui-t2 .yui-b{float:left;width:13.8461em;*width:13.50em;}.yui-t2 #yui-main .yui-b{margin-left:14.8461em;*margin-left:14.55em;}.yui-t3 .yui-b{float:left;width:23.0769em;*width:22.50em;}.yui-t3 #yui-main .yui-b{margin-left:24.0769em;*margin-left:23.62em;}.yui-t4 .yui-b{float:right;width:13.8456em;*width:13.50em;}.yui-t4 #yui-main .yui-b{margin-right:14.8456em;*margin-right:14.55em;}.yui-t5 .yui-b{float:right;width:18.4615em;*width:18.00em;}.yui-t5 #yui-main .yui-b{margin-right:19.4615em;*margin-right:19.125em;}.yui-t6 .yui-b{float:right;width:23.0769em;*width:22.50em;}.yui-t6 #yui-main .yui-b{margin-right:24.0769em;*margin-right:23.62em;}.yui-t7 #yui-main .yui-b{display:block;margin:0 0 1em 0;}#yui-main .yui-b{float:none;width:auto;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf,.yui-gc .yui-u,.yui-gd .yui-g,.yui-g .yui-gc .yui-u,.yui-ge .yui-u,.yui-ge .yui-g,.yui-gf .yui-g,.yui-gf .yui-u{float:right;}.yui-g div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first,.yui-ge div.first,.yui-gf div.first,.yui-g .yui-gc div.first,.yui-g .yui-ge div.first,.yui-gc div.first div.first{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf{width:49.1%;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{width:32%;margin-left:1.99%;}.yui-gb .yui-u{*margin-left:1.9%;*width:31.9%;}.yui-gc div.first,.yui-gd .yui-u{width:66%;}.yui-gd div.first{width:32%;}.yui-ge div.first,.yui-gf .yui-u{width:74.2%;}.yui-ge .yui-u,.yui-gf div.first{width:24%;}.yui-g .yui-gb div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first{margin-left:0;}.yui-g .yui-g .yui-u,.yui-gb .yui-g .yui-u,.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u,.yui-ge .yui-g .yui-u,.yui-gf .yui-g .yui-u{width:49%;*width:48.1%;*margin-left:0;}.yui-g .yui-g .yui-u{width:48.1%;}.yui-g .yui-gb div.first,.yui-gb .yui-gb div.first{*margin-right:0;*width:32%;_width:31.7%;}.yui-g .yui-gc div.first,.yui-gd .yui-g{width:66%;}.yui-gb .yui-g div.first{*margin-right:4%;_margin-right:1.3%;}.yui-gb .yui-gc div.first,.yui-gb .yui-gd div.first{*margin-right:0;}.yui-gb .yui-gb .yui-u,.yui-gb .yui-gc .yui-u{*margin-left:1.8%;_margin-left:4%;}.yui-g .yui-gb .yui-u{_margin-left:1.0%;}.yui-gb .yui-gd .yui-u{*width:66%;_width:61.2%;}.yui-gb .yui-gd div.first{*width:31%;_width:29.5%;}.yui-g .yui-gc .yui-u,.yui-gb .yui-gc .yui-u{width:32%;_float:right;margin-right:0;_margin-left:0;}.yui-gb .yui-gc div.first{width:66%;*float:left;*margin-left:0;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf .yui-u{margin:0;}.yui-gb .yui-gb .yui-u{_margin-left:.7%;}.yui-gb .yui-g div.first,.yui-gb .yui-gb div.first{*margin-left:0;}.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u{*width:48.1%;*margin-left:0;} .yui-gb .yui-gd div.first{width:32%;}.yui-g .yui-gd div.first{_width:29.9%;}.yui-ge .yui-g{width:24%;}.yui-gf .yui-g{width:74.2%;}.yui-gb .yui-ge div.yui-u,.yui-gb .yui-gf div.yui-u{float:right;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf div.first{float:left;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf div.first{*width:24%;_width:20%;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf .yui-u{*width:73.5%;_width:65.5%;}.yui-ge div.first .yui-gd .yui-u{width:65%;}.yui-ge div.first .yui-gd div.first{width:32%;}#bd:after,.yui-g:after,.yui-gb:after,.yui-gc:after,.yui-gd:after,.yui-ge:after,.yui-gf:after{content:".";display:block;height:0;clear:both;visibility:hidden;}#bd,.yui-g,.yui-gb,.yui-gc,.yui-gd,.yui-ge,.yui-gf{zoom:1;}</style>
    <style type="text/css">/*
Copyright (c) 2008, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.6.0
*/
h1{font-size:138.5%;}h2{font-size:123.1%;}h3{font-size:108%;}h1,h2,h3{margin:1em 0;}h1,h2,h3,h4,h5,h6,strong{font-weight:bold;}abbr,acronym{border-bottom:1px dotted #000;cursor:help;} em{font-style:italic;}blockquote,ul,ol,dl{margin:1em;}ol,ul,dl{margin-left:2em;}ol li{list-style:decimal outside;}ul li{list-style:disc outside;}dl dd{margin-left:1em;}th,td{border:1px solid #000;padding:.5em;}th{font-weight:bold;text-align:center;}caption{margin-bottom:.5em;text-align:center;}p,fieldset,table,pre{margin-bottom:1em;}input[type=text],input[type=password],textarea{width:12.25em;*width:11.9em;}
</style><meta content="Bjoern Kerler" name="author">
    <meta content="oregon scientific gnuradio decoder" name="keywords">
    <meta content="BlueGriffon wysiwyg editor" name="generator">
  </head>
  <body>
    <div class="yui-t1" id="doc3">
      <div id="hd">
        <h1><a class="mozTocH1" id="mozTocId433696"></a>Decoding Oregon
          Scientific Weatherstation Messages using Gnuradio</h1>
        <p>by B.Kerler DO2BJK (c) Jan 2015, info [at] revskills.de</p>
      </div>
      <ol id="mozToc">
        <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
        <li><a href="#mozTocId433696">Configuration</a></li>
        <li><a href="#mozTocId433696">How I figured out how it works</a></li>
        <li><a href="#mozTocId433696">How the gnuradio processor works</a></li>
        <li><a href="#mozTocId433696">Encoder versions supported</a></li>
        <li><a href="#mozTocId495465">How-To-Use</a></li>
        <li><a href="#mozTocId905847">Example Messages</a></li>
      </ol>
      <div id="ft">
        <h2><br>
          <span style="text-decoration: underline;"></span></h2>
        <h2><span style="text-decoration: underline;">Configuration</span></h2>
        Tested using Ettus Research B210 using 433 Mhz Discone Antenna. Due to
        usage of Osmocom Source, Rtl and Hackrf Dongles should work fine as
        well.<br>
        <br>
        <h2><a class="mozTocH2" id="mozTocId232036"></a><span style="text-decoration: underline;">How
            I figured out how it works</span></h2>
        First I took an example recording to see how the actual signal looks
        like using gnuradio :<br>
        <a href="Audacity%20Signal"><br>
          <img longdesc="Gnuradio Signal Identification" title="Gnuradio Signal Identification"
            alt="Gnuradio Signal Identification" src="images/gnuradio_sigint.jpg"></a><br>
        <br>
        <br>
        <br>
        Now I had to look closer at the signal. I recorded the signal to a wav
        file with 48Khz.<br>
        This way I could clearly see that the signal is being sent twice and
        that the structure was as I expected :<br>
        <br>
        <img title="Audacity Signal" alt="Audacity Signal" src="images/audacity_signal.jpg"><br>
        <span style="text-decoration: underline;"></span><br>
        The next step was to see how the bytes were encoded :<br>
        <br>
        <img title="Signal Interpretation" alt="Signal Interpretation" src="images/signal_interpretation.jpg"><br>
        <br>
        The signal starts with a "01" sequence where 0 is the value for low and
        1 is the value for high, which is being repeated 16 times for Version 2
        and 12 times for Version 1 of the<br>
        Oregon Scientific Encoder, encoded as Manchester. Thus in order to see
        the right bytes you need to leave apart every second byte. After that, a
        sync message is being sent,<br>
        which is "0101" for version 2 and "01100" for version 1.<br>
        <br>
        The main problem however started when I had to decide whether to decode
        the signal using c++, python or using gnuradio itself. It turned out
        that indeed the Binary Slicer<br>
        can be used to output a bitstream which then can be easily being used
        for further processing. However in terms of speed, I think it would be
        better to use a own slicer<br>
        and clock recovery in c++ instead. The slicer is more or less a function
        to measure if a high or low signal actually occurs. You can just use
        this pseudo-code as well instead :<br>
        <br>
        <span style="font-weight: bold;">unsigned char midlevel=0x80;<br>
          string bitstream="";<br>
          unsigned char bit=0;<br>
          while (bit=fifo-&gt;read(1)) //read one byte from stream or wav file
          (same as one bit as one byte is one symbol)<br>
          {<br>
          &nbsp; if (counter==datarate)<br>
          &nbsp; {<br>
          &nbsp;&nbsp;&nbsp; if (bit&gt;midlevel) bitstream+=1; //high detected<br>
          &nbsp;&nbsp;&nbsp; else if (bit&lt;=midlevel) bitstream+=0; //low
          detected<br>
          &nbsp;&nbsp;&nbsp; counter=0; // Start counting from 0 again<br>
          &nbsp;&nbsp;&nbsp; // Here you would create thread to handle the
          bitstream or anything else<br>
          &nbsp; }<br>
          &nbsp; counter++; // Increase counter while looping<br>
          }<br>
        </span><br>
        Here is how my gnuradio pre_processor for ask looks like :<br>
        <br>
        <img title="Gnuradio ASK" alt="Gnuradio ASK" src="images/gnuradio.jpg"><br>
        <h2><a class="mozTocH2" id="mozTocId312308"></a><span style="text-decoration: underline;"><span
              style="font-weight: bold;">How the gnuradio processor works</span></span></h2>
        <div style="text-align: justify;">First, the gain of the signal is being
          increased using AGC2 before the FIR Filter and Band Pass Filter.
          Amplitude Shift Keying turns out to be quite bad when it comes to use
          AGC2 between the FIR <br>
          and Band Pass Filters, if there are better options, please tell me :)<br>
          <br>
          After the signal has been filtered, it is being demodulated by
          AMplitude ... it doesn't matter if you use the Complex-To-Magnitude
          block instead, it works fine as well. After the signal has been
          demodulated, <br>
          you can now see the low and high signals occurring. However, as the
          signal sometimes is too weak to process by the Binary Slicer, you have
          to use a "add const" block to level the signal up. For the B210, <br>
          390m is just fine, other recievers might have to in- or decrease the
          value to get proper decoding. The Clock Recovery MM Block just
          recovers the stream according to our datarate, or in other words : it
          <br>
          picks up one sample every 47 samples, which is
          (audio_rate/data_rate)=(48000/1020)=47 samples per second, and writes
          it to a new output stream, which is thenbeing sliced (high to 1 and
          low to 0) as a <br>
          bit stream to a file.<br>
          <br>
          As the sample_rate of 2.4M is way to high to process for slow PCs, the
          Xlating FIR Filter decimates the samples by 50, which is 2.4M/50=48K.</div>
        <span style="text-decoration: underline;"></span><br>
        <span style="font-weight: bold;">Opening up the output file by
          Hex-Editor, </span>you should see something similar like this :<br>
        <br>
        <img title="HexEdit Picture" alt="HexEdit Picture" src="images/hexedit.jpg"><br>
        <br>
        I wrote a small script named "oregonscientific_test.1sc" for the
        010Editor, just position the cursor at the "00" before the "01" byte to
        get a decoding by pressing F7-Function key.<br>
        You can find both Wav- and Outputs for both Oregon-Scientific Versions 1
        and 2, which I've recorded by using my own temperature sensors.<br>
        <br>
        <span style="text-decoration: underline;"></span>
        <h2><a class="mozTocH2" id="mozTocId957436"></a><span style="text-decoration: underline;">Encoder
            versions supported</span></h2>
        <h1><a class="mozTocH1" id="mozTocId495465"></a><span style="text-decoration: underline;"></span></h1>
        <span style="font-weight: bold;">Version 1: </span><br>
        THR128H<br>
        <br>
        <span style="font-weight: bold;">Version 2: </span><br>
        THN132N, THR238NF<br>
        <br>
        <span style="text-decoration: underline;"></span>
        <h2><a class="mozTocH2" id="mozTocId979491"></a><span style="text-decoration: underline;">How-To-Use</span></h2>
        <h1><a class="mozTocH1" id="mozTocId905847"></a><span style="text-decoration: underline;"></span></h1>
        <span style="font-weight: bold;"></span>1. Install Gnuradio-Companion
        3.7 or higher<br>
	2. Get my code at <a href="https://github.com/bkerler/OregonDecoder">GitHub</a> via "git clone https://github.com/bkerler/OregonDecoder"<br>
        3. "gnuradio-companion rx_ask.grc" and run grc<br>
        4. "mkfifo /tmp/fifo" if fifo doesn't yet exist<br>
        5. "python OregonDecoder.py"<br>
        6. Select appropriate decoder Version from Tab or use any datarate for
        custom ASK-Decoders<br>
        <br>
        <span style="text-decoration: underline;"></span>
        <h2><a class="mozTocH2" id="mozTocId485070"></a><span style="text-decoration: underline;">Example
            Messages</span></h2>
        <span style="font-weight: bold;">THR132N V2:</span><br>
        FFFF A EC40 1 5F 0 730 0 D3 : FFFF=Preable, A=Sync, Flags: 1, Rolling
        Code: 5F, Temperature: 3,7°C, Checksum: 3D ok<br>
        FFFF A EC40 1 5F 0 830 0 E3 : FFFF=Preable, A=Sync, Flags: 1, Rolling
        Code: 5F, Temperature: 3,8°C, Checksum: 3E ok</div>
    </div>
  </body>
</html>
